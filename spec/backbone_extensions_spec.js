// Generated by CoffeeScript 1.6.3
(function() {
  var Backbone, Throttle, localStorage;

  Throttle = window.Throttle, Backbone = window.Backbone, localStorage = window.localStorage;

  beforeEach(function() {
    return Throttle.reset();
  });

  describe('monkey patching', function() {
    return it('aliases Backbone.sync to backboneSync', function() {
      expect(window.backboneSync).toBeDefined();
      return expect(window.backboneSync.identity).toEqual('sync');
    });
  });

  describe('offline localStorage sync', function() {
    var collection, throttler, _ref;
    _ref = {}, collection = _ref.collection, throttler = _ref.throttler;
    beforeEach(function() {
      throttler = spyOn(Throttle, 'run').andCallFake(function(name, task) {
        return task(function() {});
      });
      localStorage.clear();
      localStorage.setItem('cats', '2,3,a');
      localStorage.setItem('cats_dirty', '2,a');
      localStorage.setItem('cats_destroyed', '3');
      localStorage.setItem('cats3', '{"id": "2", "color": "auburn"}');
      localStorage.setItem('cats3', '{"id": "3", "color": "burgundy"}');
      localStorage.setItem('cats3', '{"id": "a", "color": "scarlet"}');
      collection = new Backbone.Collection([
        {
          id: 2,
          color: 'auburn'
        }, {
          id: 3,
          color: 'burgundy'
        }, {
          id: 'a',
          color: 'burgundy'
        }
      ]);
      return collection.url = function() {
        return 'cats';
      };
    });
    describe('syncDirtyAndDestroyed', function() {
      return it('calls syncDirty and syncDestroyed', function() {
        var syncDestroyed, syncDirty;
        syncDirty = spyOn(Backbone.Collection.prototype, 'syncDirty');
        syncDestroyed = spyOn(Backbone.Collection.prototype, 'syncDestroyed');
        collection.syncDirtyAndDestroyed();
        expect(syncDirty).toHaveBeenCalled();
        return expect(syncDestroyed).toHaveBeenCalled();
      });
    });
    describe('syncDirty', function() {
      return it('finds and saves all dirty models', function() {
        var saveInteger, saveString;
        saveInteger = spyOn(collection.get(2), 'save').andCallThrough();
        saveString = spyOn(collection.get('a'), 'save').andCallThrough();
        collection.syncDirty();
        expect(saveInteger).toHaveBeenCalled();
        expect(saveString).toHaveBeenCalled();
        return expect(localStorage.getItem('cats_dirty')).toBeFalsy();
      });
    });
    describe('syncDestroyed', function() {
      return it('finds all models marked as destroyed and destroys them', function() {
        var destroy;
        destroy = spyOn(collection.get(3), 'destroy');
        collection.syncDestroyed();
        return expect(localStorage.getItem('cats_destroyed')).toBeFalsy();
      });
    });
    return describe('multiple calls to syncDirty or syncDestroyed before the save completes', function() {
      return it('does not produce multiple calls to save, to prevent duplicate create/update requests', function() {
        collection.syncDirtyAndDestroyed();
        return expect(throttler.calls.length).toEqual(2);
      });
    });
  });

  describe('Throttle.run', function() {
    it('runs jobs immediately unless there is already one running', function() {
      var ran1, ran2;
      ran1 = ran2 = false;
      Throttle.run(function() {
        return ran1 = true;
      });
      Throttle.run(function() {
        return ran2 = true;
      });
      expect(ran1).toBeTruthy();
      return expect(ran2).toBeFalsy();
    });
    it('accets a job name as an optional first parameter', function() {
      var ran1, ran2, ran3, ran4;
      ran1 = ran2 = ran3 = ran4 = false;
      Throttle.run('job', function() {
        return ran1 = true;
      });
      Throttle.run('job', function() {
        return ran2 = true;
      });
      Throttle.run('another', function() {
        return ran3 = true;
      });
      Throttle.run('another', function() {
        return ran4 = true;
      });
      expect(ran1).toBeTruthy();
      expect(ran2).toBeFalsy();
      expect(ran3).toBeTruthy();
      return expect(ran4).toBeFalsy();
    });
    it('sends a callback argument to the throttled function that starts the next job when called', function() {
      var callback, ran1, ran2;
      ran1 = ran2 = false;
      callback = null;
      Throttle.run(function(runWhenDone) {
        ran1 = true;
        return callback = runWhenDone;
      });
      Throttle.run(function() {
        return ran2 = true;
      });
      expect(ran1).toBeTruthy();
      expect(ran2).toBeFalsy();
      callback();
      return expect(ran2).toBeTruthy();
    });
    it('replaces an existing queued job when a new job is queued', function() {
      var callback, ran1, ran2, ran3;
      ran1 = ran2 = ran3 = false;
      callback = null;
      Throttle.run(function(runWhenDone) {
        ran1 = true;
        return callback = runWhenDone;
      });
      Throttle.run(function() {
        return ran2 = true;
      });
      Throttle.run(function() {
        return ran3 = true;
      });
      expect(ran1).toBeTruthy();
      expect(ran2).toBeFalsy();
      expect(ran3).toBeFalsy();
      callback();
      expect(ran2).toBeFalsy();
      return expect(ran3).toBeTruthy();
    });
    return it('is done when it executes all of its jobs, but it still accepts further jobs', function() {
      var callback, ran1, ran2, ran3;
      ran1 = ran2 = ran3 = false;
      callback = null;
      Throttle.run(function(runWhenDone) {
        ran1 = true;
        return callback = runWhenDone;
      });
      Throttle.run(function(runWhenDone) {
        ran2 = true;
        return callback = runWhenDone;
      });
      Throttle.run(function() {
        return ran2 = true;
      });
      expect(ran1).toBeTruthy();
      expect(ran2).toBeFalsy();
      callback();
      expect(ran2).toBeTruthy();
      callback();
      Throttle.run(function() {
        return ran3 = true;
      });
      return expect(ran3).toBeTruthy();
    });
  });

}).call(this);
