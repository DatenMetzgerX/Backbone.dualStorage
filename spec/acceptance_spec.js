// Generated by CoffeeScript 1.7.1
(function() {
  var Collection, Model, backboneSync, collection, dualSync, localStorage, localSync, model, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  backboneSync = window.backboneSync, localSync = window.localSync, dualSync = window.dualSync, localStorage = window.localStorage;

  _ref = {}, Collection = _ref.Collection, Model = _ref.Model, collection = _ref.collection, model = _ref.model;

  describe('Backbone.dualStorage', function() {
    this.timeout(10);
    beforeEach(function() {
      backboneSync.calls = [];
      localStorage.clear();
      Model = (function(_super) {
        __extends(Model, _super);

        function Model() {
          return Model.__super__.constructor.apply(this, arguments);
        }

        Model.prototype.idAttribute = '_id';

        Model.prototype.urlRoot = 'eyes/';

        return Model;

      })(Backbone.Model);
      Collection = (function(_super) {
        __extends(Collection, _super);

        function Collection() {
          return Collection.__super__.constructor.apply(this, arguments);
        }

        Collection.prototype.model = Model;

        Collection.prototype.url = Model.prototype.urlRoot;

        return Collection;

      })(Backbone.Collection);
      collection = new Collection({
        _id: 123,
        vision: 'crystal'
      });
      return model = collection.models[0];
    });
    describe('using backbone models and retrieving from local storage', function() {
      return it("fetches a model offline after saving it online", function(done) {
        var saved;
        saved = $.Deferred();
        model.save({}, {
          success: function() {
            return saved.resolve();
          }
        });
        return saved.done(function() {
          var fetched, retrievedModel;
          fetched = $.Deferred();
          retrievedModel = new Model({
            _id: 123
          });
          retrievedModel.fetch({
            remote: false,
            success: function() {
              return fetched.resolve();
            }
          });
          return fetched.done(function() {
            expect(retrievedModel.get('vision')).to.equal('crystal');
            return done();
          });
        });
      });
    });
    describe('using backbone collections and retrieving from local storage', function() {
      return it('loads a collection after adding several models to it', function(done) {
        var allSaved, id, newModel, saved;
        allSaved = (function() {
          var _i, _results;
          _results = [];
          for (id = _i = 1; _i <= 3; id = ++_i) {
            saved = $.Deferred();
            newModel = new Model({
              _id: id
            });
            newModel.save({}, {
              success: function() {
                return saved.resolve();
              }
            });
            _results.push(saved);
          }
          return _results;
        })();
        return $.when(allSaved).done(function() {
          var fetched;
          fetched = $.Deferred();
          collection.fetch({
            remote: false,
            success: function() {
              return fetched.resolve();
            }
          });
          return fetched.done(function() {
            expect(collection.length).to.equal(3);
            expect(collection.map(function(model) {
              return model.id;
            })).to.eql([1, 2, 3]);
            return done();
          });
        });
      });
    });
    return describe('success and error callback parameters', function() {
      return it("passes back the response into the remote method's callback", function() {
        var fetched;
        fetched = $.Deferred();
        model.remote = true;
        model.fetch({
          success: function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return fetched.resolve(args);
          }
        });
        return fetched.done(function(callbackResponse) {
          expect(callbackResponse[0]).to.equal(model);
          return expect(callbackResponse[1]).to.eql(model.attributes);
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=acceptance_spec.map
